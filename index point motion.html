<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Guram Mikaberidze</title>
    <title>Guram Mikaberidze</title>
    <style>
        /* profile pannel */
        .profile-panel {
            position: fixed;
            --panelWidth: 200px;
            top: 50px;      /* Adjust the distance from the top as desired */
            right: 50px;    /* Adjust the distance from the right as desired */
            width: var(--panelWidth);   /* Ensure the width matches the profile picture width */
            height: 300px;  /* Ensure the height matches the profile picture height */
        }

        #profileEdgeCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0
        }

        #triangulationCanvas, #overlayCanvas, #backgroundCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: var(--panelWidth);
            height: var(--panelWidth);
            border-radius: 50%;
            z-index: 2; /* Ensure the main photo stays above the connecting lines */
        }
        
        #profile-pic {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            border-radius: 50%;
            z-index: 1;
        }

        .image-links {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;        
        }

        .image-links img {
            display: block;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            transition: transform 0.1s linear;
            --shift: 10px;
        }

        /* circular layout */
        .image-links a:nth-child(1) {
            --angle: 0deg;
        }
        .image-links a:nth-child(2) {
            --angle: 30deg;
        }
        .image-links a:nth-child(3) {
            --angle: -30deg;
        }

        .image-links a {
            display: flex;            /* Set the <a> tag to use flex layout */
            align-items: center;      /* Center vertically */
            justify-content: center;  /* Center horizontally */
            position: absolute;
            top: calc(var(--panelWidth)/2);
            left: 50%;
            width: 60px;
            height: 60px;
            transform: translate(-50%, -50%) rotate(var(--angle)) translateY(125px) rotate(calc(-1*var(--angle)));
            border-radius: 50%;
            overflow: hidden;
        }

        /* hover animation */
        .image-links a:hover img{
            transform: translateX(calc(-1*var(--shift)*sin(var(--angle)))) translateY(calc(var(--shift)*cos(var(--angle))));
        }

        /* FOOTER */
        #footerCanvas {
            display: block;
            background-color: #f8f8f8;
            width: 100%; /* Ensures canvas takes up full width */
            height: 200px;
        }

        footer {
            text-align: center;
            margin-top: 4em;
            padding: 2em 0;
            font-size: 0.9em;
            border-top: 1px solid #ccc;
            margin: 2% 10%;
            margin-right: calc(max(10%, 300px));
        }

        /* MAIN TEXT */
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0; /* Removes default margin */
            padding: 0; /* Removes default padding */
            background-color: #f8f8f8;
            color: #333;
        }

        header {
            position: relative;
            text-align: center;
            padding: 2em 0;
            pointer-events: none;
        }

        h1 {
            font-size: 2eem;
            padding: 0;
            margin: 0; /* Remove default margin */
            text-align: center;
        }

        h2 {
            font-size: 1em;
            border-bottom: 1px solid #ccc;
            padding-bottom: 0.5em;
            margin-top: 2em;
            margin: 2% 10%; 
            margin-right: calc(max(10%, 300px));
        }

        ul {
            list-style-type: none;
            padding: 0;
            margin: 2% 10%;
            margin-right: calc(max(10%, 300px));
        }

        li {
            padding: 0.5em 0;
        }


    </style>
</head>

<body>
    <div class="profile-panel">
        <canvas id="profileEdgeCanvas"></canvas>
        <canvas id="backgroundCanvas" style="display: none;"></canvas>
        <canvas id="triangulationCanvas" style="display: block;"></canvas>
        <canvas id="overlayCanvas" style="display: block;"></canvas>
        <img src="guga.jpg" alt="Guram Mikaberidze" id="profile-pic">

        <div class="image-links">
            <a href="https://www.researchgate.net/profile/Guram-Mikaberidze" target="_blank">
                <img src="icon_researchgate.png" alt="ResearchGate Logo">
            </a>
            <a href="https://scholar.google.com/citations?user=YOUR_GOOGLE_SCHOLAR_ID" target="_blank">
                <img src="icon_scholar_google.png" alt="Google Scholar Logo">
            </a>
            <a href="https://gitlab.com/mikaberidze" target="_blank">
                <img src="icon_gitlab.png" alt="Gitlab Logo">
            </a>
        </div>
    </div>

    <header>
        <i>Hey, I'm</i>
        <h1>Guram Mikaberidze</h1>
    </header>


    <ul>
        <li>I am a PhD candidate in Applied Mathematics at UC Davis. My research revolves around emergent dynamical phenomena on complex networks, 
            drawing inspiration from a variety of sources and applications across different scales.
            My research resonates with my national motto "ძალა ერთობაშია" which translates from Georgian to "power is in unity", emphasizing how the collective can manifest 
            properties and capabilities that surpass the sum of its individual parts. This birth of surplus complexity is the central focus of my interests.
        </li>
        <li>
            Networks manifest themselves everywhere, from quantum network of Feynman diagrams, that represents the fabric of matter to the family networks that represents 
            the fabric of evolutionary tree of life.
            From the most worying and promising Deep Neural Networks, to our mysterious brains. 
            And from the tiny protein machinary in our cells, to the massive power grids, world-wide-web, and all kinds of logistic networks and supply chains that keep our
            society running (which itself is best represented as a network)
        </li>
        <li> 
            My research usually has parts of numerical simulations and parts of analytical work.
            I use the mathematical tools from my Applied Math PhD program, the ability to neglect aspects of dynamics without reservation from the MSc in Physics, 
            and computational skills from my BSc in Computer Science.
        </li>
    </ul>

    <section>
        <h2>Education</h2>
        <ul>
            <li>Ph.D. in Applied Mathematics (expected in 2024), UC Davis, CA, USA.</li>
            <li>MS in Physics (2019), UC Davis, CA, USA.</li>
            <li>BS in Physics (2015), Free University of Tbilisi, Georgia.</li>
            <li>BS in Computer Science (2014), Free University of Tbilisi, Georgia.</li>
        </ul>
    </section>

    <section>
        <h2>Professional Interests</h2>
        <ul>
            <li>Dynamics on Networks</li>
            <li>Neuronal networks</li>
        </ul>
    </section>

    <section>
        <h2>Selected Publications</h2>
        <ul>
            <li>Mikaberidze, G., Chowdhury, S.N., Hastings, A. and D’Souza, R.M., 2023. Consensus Formation Among Mobile Agents in Networks of Heterogeneous Interaction Venues. Submitted to Nature Communications.</li>
        </ul>
    </section>

    <footer>
        Contact: [Your Email Address] | [Your Phone Number] | [LinkedIn Profile] | [GitHub Profile]
    </footer>

    <canvas id="footerCanvas" height="200"></canvas>

    <script src="https://unpkg.com/delaunator@3.0.1"></script>
    <script>
        const canvas = document.getElementById('footerCanvas');
        const ctx = canvas.getContext('2d');
        // w = canvas.width*5; // Set canvas width to window width
        // h = canvas.height*5
        // canvas.style.width = window.innerWidth; // Set canvas width to window width
        // canvas.style.width = window.innerWidth; // Set canvas width to window width
        canvas.width = window.innerWidth*5; 
        canvas.height = canvas.height*5; // Set canvas width to window width
        const points = [];
        const maxPoints = 100;
        const connectionDistance = 5*70;

        const dotSize = 10;
        const edgeWidth = 2.5;

        const gravity = 0.015; // Adjust this value to increase/decrease the strength of gravity

        class Point {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.dx = (Math.random() - 0.5) * 10;
                this.dy = (Math.random() - 0.5) * 10;
            }

            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, dotSize, 0, Math.PI * 2, false);
                ctx.fill();
            }

            update() {
                // Boundary conditions and gravity
                if (this.x + this.dx > canvas.width || this.x + this.dx < 0) {
                    this.dx = -this.dx;
                }

                if (this.y + this.dy > canvas.height || this.y + this.dy < 0) {
                    this.dy = -this.dy;
                } else {
                    this.dy += gravity;
                }

                this.x += this.dx;
                this.y += this.dy;

                this.draw();
            }
        }

        function connectDots(p1, p2) {
            const distance = Math.sqrt((p2.x - p1.x) ** 2 + (p2.y - p1.y) ** 2);
            if (distance < connectionDistance) {
                const opacity = 1 - (distance / connectionDistance)**4;
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.lineWidth = edgeWidth;
                ctx.strokeStyle = `rgba(50, 50, 50, ${opacity})`;
                ctx.stroke();
            }
        }

        function animate_footer() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            for (let i = 0; i < maxPoints - 1; i++) {
                for (let j = i + 1; j < maxPoints; j++) {
                    connectDots(points[i], points[j]);
                }
            }
            for (let i = 0; i < maxPoints; i++) {
                points[i].update();
            }
            setTimeout(requestAnimationFrame, 1, animate_footer);
        }

        for (let i = 0; i < maxPoints; i++) {
            const x = Math.random() * canvas.width;
            const y = Math.random() * canvas.height;
            points.push(new Point(x, y));
        }

        animate_footer();



        // profile pannel
        const profilePanel = document.querySelector('.profile-panel');
        const mainPic = document.querySelector('#overlayCanvas');
        const linkImages = document.querySelectorAll('.image-links a');
        const profileEdgeCanvas = document.getElementById('profileEdgeCanvas');
        const profileCtx = profileEdgeCanvas.getContext('2d');

        function drawEdges() {
            // Clear the canvas first
            profileCtx.clearRect(0, 0, profileEdgeCanvas.width, profileEdgeCanvas.height);
            
            const canvasRect = profileEdgeCanvas.getBoundingClientRect();
            const profilePanelRect = profilePanel.getBoundingClientRect();

            // Adjust canvas size to match the profilePanel's size
            profileEdgeCanvas.width = profilePanelRect.width;
            profileEdgeCanvas.height = profilePanelRect.height;

            const mainPicRect = mainPic.getBoundingClientRect();
            const mainPicCenter = {
                x: mainPicRect.left + mainPicRect.width / 2 - canvasRect.left,
                y: mainPicRect.top + mainPicRect.height / 2 - canvasRect.top
            };

            linkImages.forEach(link => {
                const rect = link.getBoundingClientRect();
                const linkCenter = {
                    x: rect.left + rect.width / 2 - canvasRect.left,
                    y: rect.top + rect.height / 2 - canvasRect.top
                };

                profileCtx.beginPath();
                profileCtx.moveTo(mainPicCenter.x, mainPicCenter.y);
                profileCtx.lineTo(linkCenter.x, linkCenter.y);
                profileCtx.stroke();
            });
        }
        // Initial drawing
        window.onload = drawEdges;

        // Profile setup with clickable triangulation
        // Setting constants for animation delay and the number of random points
        const DELAY_MS = 100;
        const POINTS_NUMBER = 2000;
        
        // Setting up variables to control animation flow
        let triangulationOn = false;
        let lastUpdateTime = 0;

        document.addEventListener('DOMContentLoaded', () => {
            // Getting the canvases and their contexts
            const backgroundCanvas = document.getElementById('backgroundCanvas');
            const ctxHidden = backgroundCanvas.getContext('2d');
            const triangulationCanvas = document.getElementById('triangulationCanvas');
            const ctxDisplay = triangulationCanvas.getContext('2d');
            const overlayCanvas = document.getElementById('overlayCanvas');
            const ctxOverlay = overlayCanvas.getContext('2d');
            const profilePic = document.getElementById('profile-pic')


            overlayCanvas.addEventListener('mousemove', () => {
                console.log("jere")
                triangulationOn = true;
            });
            overlayCanvas.addEventListener('mouseout', () => {
                triangulationOn = false;
            });
            
            // Loading the images
            const img = new Image();
            img.src = 'guga_just_background.png'; 
            const noBackgroundImg = new Image();
            noBackgroundImg.src = 'guga_no_background.png';

            const size = backgroundCanvas.width*5; // Setting size of canvases (adjusted to match CSS)
            const radius = size / 2;
            
            // Setting canvas dimensions
            backgroundCanvas.width = size;
            backgroundCanvas.height = size;
            triangulationCanvas.width = size;
            triangulationCanvas.height = size;
            overlayCanvas.width = size;
            overlayCanvas.height = size;
            
            // When images are loaded, proceed to set up canvases and start animation
            Promise.all([img.decode(), noBackgroundImg.decode()]).then(() => {    
                
                // Drawing images onto canvases
                ctxHidden.drawImage(img, 0, 0, size, size);
                ctxOverlay.drawImage(noBackgroundImg, 0, 0, size, size);

                // Animation function
                function animate() {
                    if (triangulationOn) {
                        profilePic.style.display = 'none';
                        triangulationCanvas.style.display = 'block';
                        backgroundCanvas.style.display = 'none';
                        const points = generateRandomPoints(POINTS_NUMBER, radius);
                        const delaunay = Delaunator.from(points);
                        colorAndDrawTriangles(delaunay, points, ctxHidden, ctxDisplay);
                    }else {
                        profilePic.style.display = 'block';
                        triangulationCanvas.style.display = 'none';
                        backgroundCanvas.style.display = 'block';
                    }
                    setTimeout(requestAnimationFrame, DELAY_MS, animate);
                }
                // Starting animation
                animate();
            });
        });

        // Function to generate random points within the circle
        function generateRandomPoints(count, radius) {
            const points = [];
            const centerX = radius;
            const centerY = radius;
            while (points.length < count) {
                const angle = Math.random() * Math.PI * 2;
                const r = Math.random() * radius;
                const x = centerX + r * Math.cos(angle);
                const y = centerY + r * Math.sin(angle);
                points.push([x, y]);
            }
            return points;
        }

        // Function to color and draw triangles on the display canvas
        function colorAndDrawTriangles(delaunay, points, ctxHidden, ctxDisplay) {
            ctxDisplay.clearRect(0, 0, ctxDisplay.canvas.width, ctxDisplay.canvas.height);
            for (let i = 0; i < delaunay.triangles.length; i += 3) {

                const pointIndices = [delaunay.triangles[i], delaunay.triangles[i + 1], delaunay.triangles[i + 2]];
                const trianglePoints = pointIndices.map(index => points[index]);
                
                ctxDisplay.beginPath();
                ctxDisplay.moveTo(trianglePoints[0][0], trianglePoints[0][1]);
                ctxDisplay.lineTo(trianglePoints[1][0], trianglePoints[1][1]);
                ctxDisplay.lineTo(trianglePoints[2][0], trianglePoints[2][1]);
                ctxDisplay.closePath();
                
                const centerX = (trianglePoints[0][0] + trianglePoints[1][0] + trianglePoints[2][0]) / 3;
                const centerY = (trianglePoints[0][1] + trianglePoints[1][1] + trianglePoints[2][1]) / 3;
                const color = ctxHidden.getImageData(centerX, centerY, 1, 1).data;
                ctxDisplay.fillStyle = `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${color[3] / 255})`;
                ctxDisplay.fill();
            }
        }

    </script>
</body>

</html>
